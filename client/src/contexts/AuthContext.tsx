"use client";

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import {
    UserResponse,
    UserCreate,
    AuthService,
    Body_login_auth_login_post,
    OpenAPI // Not directly used here, but good to have if needed for global config
} from '@/lib/services';
import { useRouter } from 'next/navigation';

interface AuthState {
  currentUser: UserResponse | null;
  token: string | null;
  isLoading: boolean;
  error: string | null;
  login: (email?: string, password?: string) => Promise<void>;
  register: (userData: UserCreate) => Promise<boolean>;
  logout: () => void;
  fetchCurrentUser: () => Promise<void>;
  handleGoogleCallback: (code: string, state: string) => Promise<void>;
}

const AuthContext = createContext<AuthState | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<UserResponse | null>(null);
  const [token, setToken] = useState<string | null>(() => {
    if (typeof window !== 'undefined') {
      return localStorage.getItem('authToken');
    }
    return null;
  });
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    // Initialize OpenAPI.TOKEN (if not already handled by apiClient.ts on import)
    // This ensures that on first load, if a token is in localStorage, it's used.
    if (typeof window !== 'undefined') {
        const storedToken = localStorage.getItem('authToken');
        if (storedToken) {
            OpenAPI.TOKEN = storedToken; // Make sure this matches how your apiClient.ts sets it
        }
    }

    if (token && !currentUser) {
      fetchCurrentUser().finally(() => setIsLoading(false));
    } else {
      setIsLoading(false);
    }
  }, []);


  const login = async (email?: string, password?: string) => {
    if (!email || !password) {
      setError("Email and password are required.");
      setIsLoading(false); // Ensure loading is stopped
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      const requestBody: Body_login_auth_login_post = {
        username: email, // OpenAPI spec uses 'username' for email in form data
        password: password,
        // grant_type, scope, client_id, client_secret are optional as per Body_login_auth_login_post
      };

      // AuthService.loginAuthLoginPost generated by openapi-typescript-codegen
      // should handle the application/x-www-form-urlencoded content type.
      // The generated function might take `formData` as a key in an object.
      // Let's assume it's { formData: requestBody } if that's how the tool generates it for x-www-form-urlencoded.
      // Checking the generated AuthService would clarify this. For now, trying direct object.
      // If it fails, it might need to be AuthService.loginAuthLoginPost({ formData: requestBody })
      const response = await AuthService.loginAuthLoginPost(requestBody);

      // CRITICAL ASSUMPTION: Backend login response includes access_token.
      // The OpenAPI spec for /auth/login (200 OK) shows an empty object {}.
      // This part WILL FAIL if backend doesn't return a token in the body.
      // @ts-ignore
      const new_token = response?.access_token || response?.token;
      if (!new_token && !response?.id) { // If no token, check if response looks like a User object (fallback if token is via cookie)
        // If login is via HttpOnly cookie, the response might be the user object or empty.
        // For now, we require a token in response.
        console.warn("Login response did not contain an access_token. Current OpenAPI spec for /auth/login 200 is empty.", response);
        throw new Error(response?.detail || "Login successful, but no token received in response body.");
      }

      if (new_token) {
        setToken(new_token);
        OpenAPI.TOKEN = new_token; // Update global token for subsequent API calls
        if (typeof window !== 'undefined') localStorage.setItem('authToken', new_token);
      }
      // Whether token is from response or HttpOnly cookie, try fetching current user
      await fetchCurrentUser();
      router.push('/');
    } catch (err: any) {
      console.error("Login error:", err);
      const errorDetail = err.body?.detail || err.message || 'Login failed';
      setError(errorDetail);
      setCurrentUser(null);
      setToken(null);
      OpenAPI.TOKEN = undefined;
      if (typeof window !== 'undefined') localStorage.removeItem('authToken');
    } finally {
      setIsLoading(false);
    }
  };

  const register = async (userData: UserCreate): Promise<boolean> => {
    setIsLoading(true);
    setError(null);
    try {
      await AuthService.registerAuthRegisterPost({ requestBody: userData });
      // Assuming successful registration means user should login next.
      // alert('Registration successful! Please login.'); // UI can handle this
      return true;
    } catch (err: any) {
      console.error("Registration error:", err);
      const errorDetail = err.body?.detail || err.message || 'Registration failed';
      setError(errorDetail);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const logout = () => {
    setCurrentUser(null);
    setToken(null);
    OpenAPI.TOKEN = undefined; // Clear token for API client
    if (typeof window !== 'undefined') localStorage.removeItem('authToken');
    router.push('/login');
    console.log('Logged out');
  };

  const fetchCurrentUser = async () => {
    // This function relies on OpenAPI.TOKEN being set, or token being passed directly
    // Handled by OpenAPI.TOKEN in apiClient.ts or if set explicitly like above.
    if (typeof window !== 'undefined' && !localStorage.getItem('authToken') && !token) {
      setCurrentUser(null); // No token available
      setIsLoading(false); // Ensure loading stops if called when no token
      return;
    }

    setIsLoading(true); // Set loading true at the start of fetch attempt
    try {
      const user = await AuthService.getCurrentUserInfoAuthMeGet();
      setCurrentUser(user);
      setError(null);
    } catch (err: any) {
      console.error("Failed to fetch current user:", err);
      if (err.status === 401 || err.status === 403) {
        setError('Session expired or invalid. Please login again.');
        logout(); // Automatically logout if session is invalid
      } else {
        // For other errors (network etc.), don't necessarily logout
        setError(err.body?.detail || err.message || 'Failed to fetch user data');
        // setCurrentUser(null); // Optional: clear user data on other fetch errors
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleCallback = async (code: string, state: string) => {
    setIsLoading(true);
    setError(null);
    try {
      // Backend's /auth/google/callback is hit by Google. That backend endpoint
      // should exchange code, create session/JWT. How does frontend get this JWT?
      // Option A: Backend redirects browser to frontend (e.g. /auth/token#value) - frontend parses from URL.
      // Option B: Backend sets HttpOnly cookie, redirects to frontend - browser handles cookie. API client needs withCredentials.
      // Option C: Frontend callback page calls *another* backend endpoint (e.g. /api/auth/google/exchange) sending code, gets JWT.

      // The current OpenAPI spec has GET /auth/google/callback with code, state as params.
      // This means the frontend callback page *receives* code, state from Google redirect.
      // It then *calls* GET /api/auth/google/callback (proxied to backend) with this code & state.
      // The backend's GET /auth/google/callback must then return the JWT.

      // @ts-ignore - Assuming response contains token, similar to login
      const response = await AuthService.googleCallbackAuthGoogleCallbackGet({ code, state });

      // CRITICAL ASSUMPTION: Backend /auth/google/callback response includes access_token.
      // The OpenAPI spec for this endpoint (200 OK) is an empty object {}.
      // This part WILL FAIL if backend doesn't return a token in the body for this call.
      // @ts-ignore
      const new_token = response?.access_token || response?.token;
      if (!new_token) {
         console.warn("Google callback response did not contain an access_token. Current OpenAPI spec for /auth/google/callback 200 is empty.", response);
        throw new Error(response?.detail || "Google login successful, but no token received from callback endpoint.");
      }

      setToken(new_token);
      OpenAPI.TOKEN = new_token; // Update global token
      if (typeof window !== 'undefined') localStorage.setItem('authToken', new_token);
      await fetchCurrentUser();
      router.push('/');
    } catch (err: any) {
      console.error("Google callback processing error:", err);
      const errorDetail = err.body?.detail || err.message || 'Google login processing failed.';
      setError(errorDetail);
      router.push(`/login?error=google_failed&message=${encodeURIComponent(errorDetail)}`);
    } finally {
      setIsLoading(false);
    }
  };

  // Effect to update OpenAPI.TOKEN when token state changes
  useEffect(() => {
    if (token) {
      OpenAPI.TOKEN = token;
    } else {
      OpenAPI.TOKEN = undefined;
    }
  }, [token]);


  return (
    <AuthContext.Provider value={{ currentUser, token, isLoading, error, login, register, logout, fetchCurrentUser, handleGoogleCallback }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthState => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
